import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.time.DateTimeException;import java.time.LocalDate;import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.BeforeAll;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;/** * The methods of the class CustomerVO are tested. *  * Special assert statements are used for testing <br> *  * @author Gabriele Schmidt * @version 2.0 04.02.2017 */public class JUnitTestCustomerVO {	private static CustomerVO customerDefault, customerIni;	private static CustomerVO customerX, customerY, customerZ;	private static Class<CustomerVO> myCustomerVOClass;		@BeforeAll	public static void initOnce(){				customerDefault = new CustomerVO();				customerX = new CustomerVO("Nachname", "Vorname", LocalDate.of(1990, 5, 31));		customerIni = new CustomerVO("Nachname", "Vorname", "mï¿½nnlich", LocalDate.of(1980, 1, 31));				myCustomerVOClass = CustomerVO.class;	}	@Test	public void noSettersForIdsInCustomerVO() {		Method[] methods = myCustomerVOClass.getDeclaredMethods();		for (Method m : methods) {			assertNotEquals( 					"public  void CustomerVO.setId()", m.toString(), customerDefault.getClass() + " has no setter for id");			assertNotEquals("public static void CustomerVO.setNextId()", m.toString(),					 customerDefault.getClass() + " has no setter for nextId");		}	}	@Test	public void staticGetterForNextIdInCustomerVO() {		Method[] methods = myCustomerVOClass.getDeclaredMethods();		boolean staticGetterForNextId = false;		for (Method m : methods) {			if (m.toString().equals("public static int CustomerVO.getNextId()")) {				staticGetterForNextId = true;			}		}		assertEquals(true, staticGetterForNextId,  customerDefault.getClass() + " has a static getter for nextId" );	}	@Test	public void shortCalculateAgeInCustomerVO() {		Method[] methods = myCustomerVOClass.getDeclaredMethods();		boolean returnsShort = false;		for (Method m : methods) {			if (m.toString().equals("public short CustomerVO.calculateAge()")) {				returnsShort = true;			}		}		assertEquals( true, returnsShort,  customerDefault.getClass() + " calculateAge returns short");	}	@Test	public void NoAttributeAgeInCustomerVO() {		Field[] fields = myCustomerVOClass.getDeclaredFields();		boolean attributeAge = false;		for (Field f : fields) {			if (f.toString().equals("private short CustomerVO.age")) {				attributeAge = true;			}		}		assertEquals( false, attributeAge, customerDefault.getClass() + " field age");	}	@Test	public void idInCustomerVO() {		assertEquals( 0, customerDefault.getId(), customerDefault.getClass() + " has the ID 0");		assertEquals( 2, customerIni.getId(), customerIni.getClass() + " has the ID  1");		// IDs are increaded correctly		for (int i = customerIni.getNextId(); i < customerIni.getId() + 10; i++) {			customerDefault = new CustomerVO();			assertEquals( i, customerDefault.getId(), customerDefault.getClass() + " has the ID  " + i);		}		// the once giben ID can't be changed		assertEquals( 2, customerIni.getId(),customerIni.getClass() + "  has the ID  1");	}	@Test	public void setDateOfBirthInCustomerVO() {		int age = 31;		LocalDate today = LocalDate.now();		int year = today.getYear();		int month = today.getMonthValue();		int day = today.getDayOfMonth();		customerIni.setDateOfBirth(LocalDate.of(year - age, month, day));		assertEquals(year - age,				customerIni.getDateOfBirth().getYear(),  customerIni.getClass() + " has day of birth in the year " + (year - age) );				assertEquals( month,				customerIni.getDateOfBirth().getMonthValue(), customerIni.getClass() + " has day of birth in the month " + month);		assertEquals( day,				customerIni.getDateOfBirth().getDayOfMonth(), customerIni.getClass() + " has day of birth on the day " + day);		// Month January		customerIni.setDateOfBirth(LocalDate.of(year - age, 1, day));		assertEquals( 1,				customerIni.getDateOfBirth().getMonthValue(), customerIni.getClass() + " has day of birth in January");		// set age too young		age = 12;		customerIni.setDateOfBirth(LocalDate.of(year - age, month, day));		assertEquals( null, customerIni.getDateOfBirth(), customerIni.getClass() + " has day of birth in the year " + (year - age)				+ ", is to young and since no object");		// set ager 60		age = 60;		customerIni.setDateOfBirth(LocalDate.of(year - age, month, day));		assertEquals(								LocalDate.of(year - age, month, day), customerIni.getDateOfBirth(), customerIni.getClass() + " has day of birth in the year" + (year - age)				+ ", is to old and since no object");		// set age leap year		customerIni.setDateOfBirth(LocalDate.of(1964, 2, 29));		assertNotNull(				customerIni.getDateOfBirth(), customerIni.getClass() + " has day of birth on 29th of february 1964 and is since an object");	}	// set wrong date, z. B. 30.2.1967	// Exception expected	// @Test(expected = DateTimeException.class)	@Test	public void setDateOfBirthInCustomerVOWithException() {				Assertions.assertThrows(DateTimeException.class, () ->		customerIni.setDateOfBirth(LocalDate.of(1967, 2, 30)));	}	// set date null	@Test	public void setDateOfBirthInCustomerVONull() {		customerIni.setDateOfBirth(null);	}	@Test	public void calculateAgeInCustomerVO() {		int alter;		LocalDate today = LocalDate.now();		int year = today.getYear();		int month = today.getMonthValue();		int day = today.getDayOfMonth();		// date of birth is null, alter -1		customerIni.setDateOfBirth(null);		assertEquals( -1, customerIni.calculateAge(), customerIni.getClass() + " has the age null");		assertEquals( null,				customerIni.getDateOfBirth(), customerIni.getClass() + " Geburtsdaum wurde auf null gesetzt ");		// 16 years old		alter = 16;		customerIni.setDateOfBirth(LocalDate.of(year - alter, month, day));		assertEquals( -1, customerIni.calculateAge(), customerIni.getClass() + " has the age " + alter);		assertEquals( null,				customerIni.getDateOfBirth(),customerIni.getClass() + " Geburtsdaum wurde auf null gesetzt ");		// 18 years old		alter = 18;		customerIni.setDateOfBirth(LocalDate.of(year - alter, month, day));		assertEquals( 18, customerIni.calculateAge(), customerIni.getClass() + " has the age " + alter);		// 18 years old minus 1 day		alter = 18;		customerIni.setDateOfBirth(LocalDate.of(year - alter, month, day + 1));		assertEquals( -1,				customerIni.calculateAge(), customerIni.getClass() + " has the age 1 day before 18th birthday");		// 60 years old		alter = 60;		customerIni.setDateOfBirth(LocalDate.of(year - alter, month, day));		assertEquals( alter, customerIni.calculateAge(), customerIni.getClass() + " has the age " + alter);		// 60 years old minus 1 day		alter = 60;		customerIni.setDateOfBirth(LocalDate.of(year - alter, month, day + 1));		assertEquals( 59, customerIni.calculateAge(), customerIni.getClass() + " has the age 1 Tag vor dem 60. Geb.");		// 71 years old		alter = 71;		customerIni.setDateOfBirth(LocalDate.of(year - alter, month, day));		assertEquals(alter, customerIni.calculateAge(), customerIni.getClass() + " has the age " + alter);	}	@Test	public void equalsInCustomerVO() {		customerY = customerX;		customerZ = customerY;		// For any non-null reference value x, x.equals(null) should return		// false.		assertFalse(customerX.equals(null), "For any non-null reference value x, x.equals(null) should return false.");		// It is reflexive: for any non-null reference value x, x.equals(x)		// should return true.		assertTrue(				customerY.equals(customerY), "It is reflexive: for any non-null reference value x, x.equals(x) should return true. ");		// It is symmetric: for any non-null reference values x and y,		// x.equals(y) should return true if and only if y.equals(x) returns		// true.		assertTrue(								customerX.equals(customerY) == customerY.equals(customerX), "It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true. ");		// It is transitive: for any non-null reference values x, y, and z, if		// x.equals(y) returns true and y.equals(z) returns true, then		// x.equals(z) should return true.		assertTrue(								(customerX.equals(customerY) && customerY.equals(customerZ)) ? customerX.equals(customerZ) : false, "It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. ");		// Equals		assertTrue(				customerY.equals(customerX), customerY.getClass() + " equals arbeitet bei gleichen Objekten richtig ");		customerZ = new CustomerVO("Anders", "Hans", LocalDate.of(1999, 12, 31));		assertFalse(				customerZ.equals(customerX), customerZ.getClass() + " equals arbeitet bei ungleichen Objekten richtig ");		assertFalse( customerZ.equals(new PizzaVO()), customerZ.getClass() + " equals arbeitet bei falschen Objekten (Nicht-" + customerZ.getClass()		+ " richtig ");	}	@Test	public void equalsHashCodeInCustomerVO() {		customerX = new CustomerVO("Nachname", "Vorname", LocalDate.of(1969, 10, 11));		customerY = customerX;		// Simliar objects provide similar hashcode		assertTrue(				customerX.equals(customerY) == (customerX.hashCode() == customerY.hashCode()),"Simliar objects provide similar hashcode");	}}