import static org.junit.jupiter.api.Assertions.assertArrayEquals;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;/** * The methods of the class PizzaVO are tested. *  * Special assert statements are used for testing <br> *  * @author Gabriele Schmidt * @version 2.0 04.02.2017 */public class JUnitTestPizzaVO {	private static PizzaVO pizzaIni, pizzaWithout;		private static PizzaVO pizzaX, pizzaY, pizzaZ;	@BeforeEach	public void initEach() {		pizzaIni = new PizzaVO("Marghrita",new String [] {"Tomaten","Käse","Basilikum"},8.0f);		pizzaWithout = new PizzaVO();	}		@Test	public void ingredientsInPizzaVO() {		assertArrayEquals( new String [] {"Tomaten","Käse","Basilikum"},pizzaIni.getIngredients(),				pizzaIni.getClass()				+ " checks the incredients");	}		@Test	public void setIngredientsInPizzaVO() {		String s [] = {"Tomaten","Käse","Anchovis"};				pizzaWithout.setIngredients(s);				assertArrayEquals(s, pizzaWithout.getIngredients(),				pizzaWithout.getClass()				+ " checks the setter of incredients");	}		@Test	public void setNameInPizzaVO() {		String name = "Anchovi";				pizzaWithout.setName(name);				assertEquals(name, pizzaWithout.getName(), pizzaWithout.getClass() +				" checks the setter of name");	}		@Test	public void setPriceInPizzaVO() {		float price = 10.5f;		pizzaWithout.setPrice(price);		assertEquals(price,pizzaWithout.getPrice());	}		@Test	public void setNegativePriceInPizzaVO() {		pizzaWithout.setPrice(-10.5f);		assertEquals(0f,pizzaWithout.getPrice(), pizzaWithout.getClass()				+ " checks the setter of price sets no negative price");	}	@Test	public void cloneInPizzaVO() {		assertEquals(pizzaIni,				pizzaIni.clone(),pizzaIni.getClass()				+ " creates a copy using the clone method");				assertFalse(				pizzaIni == pizzaIni.clone(),"Clone of  " + pizzaIni.getClass()				+ " creates a real copy");	}	@Test	public void valuesInPizzaVO() {		assertTrue(				pizzaIni.getPrice() >= 0,pizzaIni.getClass() + " not a negative price ");			}		@Test	public void equalsInPizzaVO() {		pizzaX = new PizzaVO("Marghrita",new String [] {"Tomaten","K�se","Basilikum"},8.0f);		pizzaY =  new PizzaVO("Marghrita",new String [] {"Tomaten","K�se","Basilikum"},8.0f);		pizzaZ =  new PizzaVO("Marghrita",new String [] {"Tomaten","K�se","Basilikum"},8.0f);				//For any non-null reference value x, x.equals(null) should return false. 		assertFalse( pizzaX.equals(null),"For any non-null reference value x, x.equals(null) should return false.");						//Tow Objects		assertTrue( pizzaY != pizzaX, pizzaY.getClass() + " erstellt mit dem Initialisierungskonstruktor neue Objekte ");				//It is reflexive: for any non-null reference value x, x.equals(x) should return true. 		assertTrue(pizzaY.equals(pizzaY), "It is reflexive: for any non-null reference value x, x.equals(x) should return true. ");				//It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.  		assertTrue(pizzaX.equals(pizzaY) == pizzaY.equals(pizzaX), "It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true. ");					//It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.   		assertTrue((pizzaX.equals(pizzaY) && pizzaY.equals(pizzaZ)) ? pizzaX.equals(pizzaZ): false, "It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. " );					//Equals		assertTrue( pizzaY.equals(pizzaX),pizzaY.getClass() + " equals arbeitet bei gleichen Objekten richtig ");				assertTrue( pizzaY.equals(pizzaY),pizzaY.getClass() + " equals arbeitet bei identischen Objekten richtig ");				pizzaZ.setPrice(8.50f);		assertFalse( pizzaZ.equals(pizzaX),pizzaZ.getClass() + " equals arbeitet bei ungleichen Objekten richtig ");				assertFalse( pizzaZ.equals(new PizzaVO()),pizzaZ.getClass() + " equals arbeitet bei falschen Objekten (Nicht-" + pizzaZ.getClass() + " richtig ");	}		@Test	public void equalsHashCodeInPizzaVO() {		pizzaX = new PizzaVO("Marghrita",new String [] {"Tomaten","K�se","Basilikum"},8.0f);		pizzaY = new PizzaVO("Marghrita",new String [] {"Tomaten","K�se","Basilikum"},8.0f);		//Simliar objects provide similar hashcode		assertTrue(pizzaX.equals(pizzaY) == ( pizzaX.hashCode() == pizzaY.hashCode()),"Gleiche Objekte liefern den gleichen HashCode");		}}